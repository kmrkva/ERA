    <script>
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const previewSection = document.getElementById('previewSection');
        const previewImage = document.getElementById('previewImage');
        const generateBtn = document.getElementById('generateBtn');
        const loading = document.getElementById('loading');
        const resultsSection = document.getElementById('resultsSection');
        const codeContent = document.getElementById('codeContent');
        const copyBtn = document.getElementById('copyBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const resetBtn = document.getElementById('resetBtn');
        const responseContainer = document.getElementById('responseContainer');
        const responseContent = document.getElementById('responseContent');

        let selectedFile = null;
        let cleanHtmlCode = '';

        // Upload area click handler
        uploadArea.addEventListener('click', () => {
            fileInput.click();
        });

        // Drag and drop handlers
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileSelect(files[0]);
            }
        });

        // File input change handler
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileSelect(e.target.files[0]);
            }
        });

        // Handle file selection
        function handleFileSelect(file) {
            if (!file.type.startsWith('image/')) {
                showError('Please select an image file.');
                return;
            }

            if (file.size > 10 * 1024 * 1024) {
                showError('File size must be less than 10MB.');
                return;
            }

            selectedFile = file;
            
            // Show preview
            const reader = new FileReader();
            reader.onload = (e) => {
                previewImage.src = e.target.result;
                previewSection.style.display = 'block';
                resultsSection.style.display = 'none';
            };
            reader.readAsDataURL(file);
        }

        // Extract clean HTML from response
        function extractCleanHtml(response) {
            // Remove <Thinking> tags and content
            let cleaned = response.replace(/<Thinking>[\s\S]*?<\/Thinking>/gi, '');
            
            // Remove common AI response phrases at the beginning
            cleaned = cleaned.replace(/^[\s\S]*?I'll (recreate|create|build|make)[\s\S]*?(?=<!DOCTYPE)/i, '');
            cleaned = cleaned.replace(/^[\s\S]*?Let me (recreate|create|build|make)[\s\S]*?(?=<!DOCTYPE)/i, '');
            cleaned = cleaned.replace(/^[\s\S]*?Here's[\s\S]*?(?=<!DOCTYPE)/i, '');
            
            // Find the HTML content starting with <!DOCTYPE
            const htmlStart = cleaned.search(/<!DOCTYPE\s+html/i);
            if (htmlStart !== -1) {
                cleaned = cleaned.substring(htmlStart);
            }
            
            // Remove any trailing text after </html>
            const htmlEnd = cleaned.lastIndexOf('</html>');
            if (htmlEnd !== -1) {
                cleaned = cleaned.substring(0, htmlEnd + 7);
            }
            
            return cleaned.trim();
        }

        // Generate HTML
        generateBtn.addEventListener('click', async () => {
            if (!selectedFile) return;

            generateBtn.disabled = true;
            loading.style.display = 'block';
            resultsSection.style.display = 'none';

            const formData = new FormData();
            formData.append('screenshot', selectedFile);
            
            // Add the specific prompt for v0.dev-style generation
            formData.append('prompt', 'Please recreate this UI as a fully functional HTML webpage with JavaScript. All interactive elements should work as they would on the real website - clicking different options should select them, buttons should be clickable, and any user interactions should have appropriate visual feedback and state changes.');

            try {
                const response = await fetch('/generate', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    const fullResponse = result.text;
                    cleanHtmlCode = extractCleanHtml(fullResponse);
                    
                    // Display the clean HTML code
                    codeContent.textContent = cleanHtmlCode;
                    
                    // Show AI response (optional - can be hidden if not needed)
                    if (fullResponse !== cleanHtmlCode) {
                        const responseText = fullResponse.replace(cleanHtmlCode, '').trim();
                        if (responseText) {
                            responseContent.textContent = responseText;
                            responseContainer.style.display = 'block';
                        }
                    }
                    
                    resultsSection.style.display = 'block';
                    showSuccess('HTML generated successfully!');
                } else {
                    showError(result.error || 'Failed to generate HTML');
                }
            } catch (error) {
                console.error('Error:', error);
                showError('Network error. Please try again.');
            } finally {
                loading.style.display = 'none';
                generateBtn.disabled = false;
            }
        });

        // Copy code to clipboard
        copyBtn.addEventListener('click', async () => {
            try {
                await navigator.clipboard.writeText(cleanHtmlCode);
                copyBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyBtn.textContent = 'Copy Code';
                }, 2000);
            } catch (error) {
                console.error('Failed to copy:', error);
                showError('Failed to copy to clipboard');
            }
        });

        // Download HTML file
        downloadBtn.addEventListener('click', () => {
            if (!cleanHtmlCode) {
                showError('No HTML code to download');
                return;
            }

            const blob = new Blob([cleanHtmlCode], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'generated-webpage.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            downloadBtn.textContent = 'Downloaded!';
            setTimeout(() => {
                downloadBtn.textContent = 'Download HTML';
            }, 2000);
        });

        // Reset for another generation
        resetBtn.addEventListener('click', () => {
            selectedFile = null;
            cleanHtmlCode = '';
            fileInput.value = '';
            previewSection.style.display = 'none';
            resultsSection.style.display = 'none';
            responseContainer.style.display = 'none';
            loading.style.display = 'none';
            clearMessages();
        });

        // Utility functions
        function showError(message) {
            clearMessages();
            const error = document.createElement('div');
            error.className = 'error';
            error.textContent = message;
            document.querySelector('.upload-section').appendChild(error);
        }

        function showSuccess(message) {
            clearMessages();
            const success = document.createElement('div');
            success.className = 'success';
            success.textContent = message;
            resultsSection.appendChild(success);
        }

        function clearMessages() {
            document.querySelectorAll('.error, .success').forEach(el => el.remove());
        }
    </script>